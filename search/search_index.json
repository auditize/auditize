{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Empower your functional logs      Auditize is a comprehensive audit log solution designed to integrate auditability seamlessly into your software.         Get started    REST API       Send your logs to Auditize using an easy-to-use REST API.      Multi-tenancy       Partition your logs using log repositories. Each repository use its own database, and users and API keys can be granted different permissions on a specific set of repositories.      Log UI       Explore your logs with advanced search criteria, saveable filters, CSV export, and more.      Internationalization       Auditize is available in multiple languages and also supports internationalization of your logs through translation profiles.      Entity Mapping       Map your own organisational entities into Auditize. Entities can be anything: a customer, an organizational unit, a geographical location, etc. They can be used for log filtering but also to restrict user access to certain log entities.      Log data model <p>Auditize features a rich and flexible log data model. Given a base set of fields that allow you to describe the actor, the action, the resource, tags, etc. you can extend the actor and resource fields with custom fields. Source and details fields which are fully customizable allow you to provide additional context to the log.</p> <p>Files can also be attached to logs.</p> Web Component       Integrate the log interface right into your application frontend using a Web Component.      OpenAPI       Entire Auditize REST API is documented using OpenAPI."},{"location":"config/","title":"Configuration","text":"<p>The base Auditize configuration is done through environment variables. The following variables are available:</p> Variable Required or default Description <code>AUDITIZE_CONFIG</code> The path to an environment file (key-value pairs) containing the configuration. If set, the configuration will be loaded from this file instead of environment variables. <code>AUDITIZE_PUBLIC_URL</code> Required The public URL of your Auditize instance from which your users access Auditize. It will be used for instance to build the URL of the application in emails sent to users. <code>AUDITIZE_JWT_SIGNING_KEY</code> Required The secret key used to sign the JWT tokens (user session cookies and access tokens). It must be a long random string. A 32 bytes long key is recommended (i.e 64 characters in hexadecimal representation), you can generate one with the command <code>openssl rand -hex 32</code>. <code>AUDITIZE_DB_NAME</code> <code>auditize</code> The main database name. <code>AUDITIZE_PG_HOST</code> <code>localhost</code> The PostgreSQL server hostname or IP address. <code>AUDITIZE_PG_PORT</code> <code>5432</code> The PostgreSQL server port. <code>AUDITIZE_PG_USER</code> <code>${USER}</code> The PostgreSQL database user. <code>AUDITIZE_PG_PASSWORD</code> The PostgreSQL database password. <code>AUDITIZE_ES_URL</code> <code>http://localhost:9200</code> The Elasticsearch server URL. <code>AUDITIZE_ES_USERNAME</code> The Elasticsearch username (if authentication is enabled). <code>AUDITIZE_ES_PASSWORD</code> The Elasticsearch password (if authentication is enabled). <code>AUDITIZE_ES_SSL_VERIFY</code> <code>true</code> Whether to verify the SSL certificate of the Elasticsearch server. <code>AUDITIZE_SMTP_SERVER</code> The SMTP server used to send emails. <code>AUDITIZE_SMTP_PORT</code> The SMTP server port. <code>AUDITIZE_SMTP_USERNAME</code> The SMTP account username. <code>AUDITIZE_SMTP_PASSWORD</code> The SMTP account password. <code>AUDITIZE_SMTP_SENDER</code> Defaults to <code>$AUDITIZE_SMTP_USERNAME</code> The email address used to send emails. <code>AUDITIZE_LOG_EXPIRATION_SCHEDULE</code> <code>0 1 * * *</code> (every day at 1AM) The schedule at which expired logs are deleted. <code>AUDITIZE_COOKIE_SECURE</code> <code>false</code> Whether the user session cookie should be secure (only sent over HTTPS). It is recommended to set this to <code>true</code> in production. <code>AUDITIZE_CORS_ALLOW_ORIGINS</code> A comma-separated list of origins allowed to make HTTP requests to Auditize. <code>AUDITIZE_USER_SESSION_TOKEN_LIFETIME</code> <code>43200</code> (12 hours) The lifetime of user session tokens in seconds. <code>AUDITIZE_ACCESS_TOKEN_LIFETIME</code> <code>600</code> (10 minutes) The lifetime of access tokens in seconds. <code>AUDITIZE_ATTACHMENT_MAX_SIZE</code> <code>5242880</code> (5MB) The maximum file size of attachments in bytes. <code>AUDITIZE_CSV_MAX_ROWS</code> <code>10000</code> The maximum number of rows in CSV exports (<code>0</code> means no limit)."},{"location":"install/","title":"Installation","text":"<p>Auditize is a Python 3.12+ application that uses PostgreSQL and Elasticsearch as databases and do not use the filesystem to persist data. It's base configuration is 100% environment variables based, making it easy and flexible to configure, especially in a Docker environment.</p> <p>Auditize is composed of two distinct services:</p> <ul> <li>an ASGI web application that serves both the API and the frontend</li> <li>a scheduler that runs period tasks</li> </ul> <p>It is delivered as a Python package on PyPI that can be installed with <code>pip</code> (the package installer for Python). Please note that the Auditize package dependencies are pinned to ensure a stable and reproducible installation.</p> <p>By default, Auditze uses <code>auditize</code> as PostgreSQL database name and also use <code>auditize</code> as an Elasticsearch index prefix: <code>auditize_logs_{repo_id}</code>. This can be changed through the <code>AUDITIZE_DB_NAME</code> configuration variable.</p> <p>The following sections will guide you through the installation of Auditize in two different contexts:</p> <ul> <li>a Docker Compose environment</li> <li>a standalone environment</li> </ul>"},{"location":"install/#docker-compose","title":"Docker Compose","text":"<p>The Docker Compose environment described here provides a complete Auditize setup including PostgreSQL and Elasticsearch.</p> <p>First, create an <code>auditize-docker</code> directory where you will store the various files related to your Auditize's Docker setup, and go to this directory:</p> <pre><code>mkdir auditize-docker\ncd auditize-docker\n</code></pre> <p>Then, create a <code>Dockerfile</code> file with the following content:</p> <pre><code>FROM python:3.12\n\nRUN pip install auditize\n\nEXPOSE 80\n\nENTRYPOINT [\"auditize\"]\n</code></pre> <p>Warning</p> <p>This is a minimal Dockerfile that installs the <code>auditize</code> package and exposes the port 80. In a real-world / production setup, you would typically implement security and optimization measures such as:</p> <ul> <li>running the application as a non-root user,</li> <li>using a non-privileged port,</li> <li>making the Docker image as small as possible by using an optimized base image,</li> <li>pin the version of the <code>auditize</code> package to a specific version,</li> <li>etc.</li> </ul> <p>This image will be used to run both the web application and the scheduler Docker Compose services.</p> <p>Next, create a <code>docker-compose.yml</code> file in the same directory with the following content:</p> <pre><code>name: auditize\n\nx-auditize-variables: &amp;auditize-variables\n  AUDITIZE_PG_HOST: postgres\n  AUDITIZE_PG_USER: auditize\n  AUDITIZE_PG_PASSWORD: auditize\n  AUDITIZE_ES_URL: http://elastic:9200\n\nservices:\n  postgres:\n    image: postgres:17\n    restart: always\n    environment:\n      POSTGRES_USER: auditize\n      POSTGRES_PASSWORD: auditize\n      POSTGRES_DB: auditize\n    volumes:\n      - ./data/postgres:/var/lib/postgresql/data\n  elastic:\n    image: elasticsearch:8.19.4\n    environment:\n      - discovery.type=single-node\n      - xpack.security.enabled=false\n    volumes:\n      - ./data/elastic:/usr/share/elasticsearch/data\n  web:\n    image: auditize\n    build: .\n    depends_on:\n      - postgres\n      - elastic\n    command: [\"serve\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n    ports:\n      - \"8000:8000\"\n    env_file: \".env\"\n    environment:\n      &lt;&lt;: *auditize-variables\n  scheduler:\n    image: auditize\n    depends_on:\n      - postgres\n      - elastic\n    command: [\"schedule\"]\n    env_file: \".env\"\n    environment:\n      &lt;&lt;: *auditize-variables\n      # we set PYTHONUNBUFFERED, otherwise the print() from \"schedule\" are not shown\n      PYTHONUNBUFFERED: 1\n</code></pre> <p>This <code>docker-compose.yml</code> uses a <code>.env</code> file for the Auditize base-configuration, so let's create a <code>.env</code> file in the same directory with at least the following configuration elements:</p> <pre><code>AUDITIZE_PUBLIC_URL=http://localhost:8000\nAUDITIZE_JWT_SIGNING_KEY=YOUR_AUDITIZE_JWT_SIGNING_KEY\n</code></pre> <ul> <li><code>AUDITIZE_PUBLIC_URL</code> is the public URL of your Auditize instance from which the web application will be accessed by your users or API clients (e.g. <code>https://auditize.example.com</code>). It is used to generate URLs in the emails sent by Auditize.</li> <li><code>AUDITIZE_JWT_SIGNING_KEY</code> is the key used to sign the JWT tokens generated by Auditize (e.g. user sessions).</li> </ul> <p>Please refer to the configuration documentation for more details.</p> <p>Build the <code>auditize</code> Docker image:</p> <pre><code>docker compose build\n</code></pre> <p>Run the services:</p> <pre><code>docker compose up -d\n</code></pre> <p>Then, create the database schema for PostgreSQL:</p> <pre><code>docker exec -it auditize-web-1 auditize migrate-db\n</code></pre> <p>In order to login on Auditize, you need to create a superadmin user. You can do this by running the following command:</p> <pre><code>docker exec -it auditize-web-1 auditize bootstrap-superadmin YOUR_EMAIL YOUR_FIRST_NAME YOUR_LAST_NAME\n</code></pre> <p>Where:</p> <ul> <li><code>auditize-web-1</code> is the name of the web container to run the command from</li> <li><code>YOUR_EMAIL</code>, <code>YOUR_FIRST_NAME</code>, and <code>YOUR_LAST_NAME</code> must be replaced by your actual user information</li> </ul> <p>The command will prompt you for a password and then create the superadmin user.</p> <p>You can now access Auditize at <code>http://localhost:8000</code> and log in with the superadmin user you just created.</p>"},{"location":"install/#using-gunicorn","title":"Using Gunicorn","text":"<p>The previous setup uses <code>auditize serve</code> to run the web application. What this command does under the hood is to run the Uvicorn ASGI server with one worker. You may want to use Gunicorn with multiple workers for better performance as recommended in the Uvicorn documentation.</p> <p>In this case, you can follow the same steps as above but make the following change in <code>Dockerfile</code>:</p> <pre><code># RUN pip install auditize\nRUN pip install auditize gunicorn\n</code></pre> <p>And this change in the <code>docker-compose.yml</code> file:</p> <pre><code># command: [\"serve\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"]\nentrypoint:\n  [\n    \"gunicorn\",\n    \"auditize:asgi()\",\n    \"-k\",\n    \"uvicorn.workers.UvicornWorker\",\n    \"-w\",\n    \"4\",\n    \"-b\",\n    \"0.0.0.0:80\",\n  ]\n</code></pre> <p>In this example, Gunicorn is configured to run 4 workers with the Uvicorn worker class. You can adjust the number of workers according to your needs / host resources.</p> <p>Note</p> <p>Since Auditize is an ASGI application, you can use any other ASGI server to run it instead of Uvicorn or Uvicorn+Gunicorn.</p>"},{"location":"install/#ngnix-tls-kubernetes-and-beyond","title":"Ngnix, TLS, Kubernetes and beyond","text":"<p>The Docker Compose environment described above is a good starting point to run Auditize in a development/test environment. For a production deployment, you may consider:</p> <ul> <li>using a reverse proxy such as Nginx to serve the web application and handle TLS termination,</li> <li>deploying Auditize in a Kubernetes cluster with a proper ingress controller,</li> <li>build a custom Docker image with security and optimization measures,</li> <li>etc.</li> </ul> <p>When deploying Auditize in a Kubernetes cluster, you have the flexibility to scale it by choosing between multiple pods running directly with Uvicorn and a single worker (through <code>auditize serve</code>) or using Gunicorn with multiple workers. Using Uvicorn directly in each pod can be simpler and more lightweight, making it easier to manage and scale horizontally. The FastAPI documentation provides more information on how to deploy a FastAPI application in Kubernetes.</p> <p>Info</p> <p>You can also take a look at the auditize-docker repository which provides an exemple of Docker Compose environment with Nginx proxying and automatic SSL certificate generation using Let's Encrypt.</p>"},{"location":"install/#standalone","title":"Standalone","text":""},{"location":"install/#introduction","title":"Introduction","text":"<p>Auditize supports Python 3.12+. This version of Python is available on Ubuntu 24.04+ and RHEL 9.4+ (among others) as time of writing.</p> <p>In this section, we will build a standalone Auditize environment using:</p> <ul> <li>Auditize installed in a Python virtual environment</li> <li>Gunicorn with ASGI workers</li> <li>Nginx as a reverse proxy</li> </ul> <p>We assume that you have working PostgreSQL and Elasticsearch instances available, a database created for Auditize and the corresponding connection details.</p> <p>Here, we take Ubuntu 24.04 as an example, but the steps should be similar for other Linux distributions (especially Debian-based ones and distros using <code>systemd</code>).</p>"},{"location":"install/#install-and-configure-auditize","title":"Install and configure Auditize","text":"<p>First, install the <code>virtualenv</code> package and create a Python virtual environment with Auditize and Gunicorn:</p> <pre><code>sudo apt install -y python3-virtualenv\nsudo virtualenv /opt/auditize\nsudo /opt/auditize/bin/pip install auditize gunicorn\n</code></pre> <p>Create a <code>/opt/auditize/env</code> file containing your Auditize configuration. It should contain at least the required fields <code>AUDITIZE_PUBLIC_URL</code>, <code>AUDITIZE_JWT_SIGNING_KEY</code>, and also <code>AUDITIZE_PG_*</code> and <code>AUDITIZE_ES_*</code> according to your PostgreSQL and Elasticsearch setup.</p> <pre><code>AUDITIZE_PUBLIC_URL=...\nAUDITIZE_JWT_SIGNING_KEY=...\n...\n</code></pre> <p>Then, ensure appropriate permissions and ownership on this file:</p> <pre><code>sudo chown www-data:www-data /opt/auditize/env\nsudo chmod 660 /opt/auditize/env\n</code></pre> <p>Create the database schema for PostgreSQL:</p> <pre><code>sudo AUDITIZE_CONFIG=/opt/auditize/env /opt/auditize/bin/auditize migrate-db\n</code></pre> <p>Bootstrap the superadmin user:</p> <pre><code>sudo AUDITIZE_CONFIG=/opt/auditize/env /opt/auditize/bin/auditize bootstrap-superadmin YOUR_EMAIL YOUR_FIRST_NAME YOUR_LAST_NAME\n</code></pre> <p>The <code>auditize bootstrap-superadmin</code> command will prompt you for a password and then create the superadmin user.</p> <p>Info</p> <p>The install path <code>/opt/auditize</code> can be changed to any other path you prefer (when doing so, make sure to adjust the paths in the following steps accordingly). We use the <code>www-data</code> user to run the services for simplicity, but you can choose to create a dedicated user for Auditize (you will have to ensure that the <code>/run/gunicorn.sock</code> socket file is still accessible by Nginx that runs as <code>www-data</code>).</p>"},{"location":"install/#run-auditizes-scheduler-with-systemd","title":"Run Auditize's scheduler with systemd","text":"<p>First, create a <code>/opt/auditize/log</code> directory to store the logs:</p> <pre><code>sudo mkdir /opt/auditize/log\nsudo chown www-data:www-data /opt/auditize/log\n</code></pre> <p>Then, create a <code>/etc/systemd/system/auditize-scheduler.service</code> file with :</p> <pre><code>[Unit]\nDescription=Auditize Scheduler\nAfter=network.target\n\n[Service]\nUser=www-data\nWorkingDirectory=/opt/auditize\nEnvironmentFile=/opt/auditize/env\nEnvironment=PYTHONUNBUFFERED=1\nExecStart=/opt/auditize/bin/auditize schedule\nRestart=always\nRestartSec=3\nStandardOutput=append:/opt/auditize/log/scheduler.log\nStandardError=append:/opt/auditize/log/scheduler-error.log\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>And activate the service:</p> <pre><code>sudo systemctl enable --now auditize-scheduler\n</code></pre>"},{"location":"install/#run-gunicorn-with-systemd","title":"Run Gunicorn with systemd","text":"<p>We are going to use <code>systemd</code> to create a UNIX socket for Gunicorn. Nginx will forward requests to this socket and <code>systemd</code> will start the Gunicorn service when the first request is received.</p> <p>Create a <code>/etc/systemd/system/auditize-gunicorn.socket</code> file with:</p> <pre><code>[Unit]\nDescription=Unix socket for Auditize Gunicorn\n\n[Socket]\nListenStream=/run/gunicorn.sock\nSocketUser=www-data\nSocketGroup=www-data\nSocketMode=0660\n\n[Install]\nWantedBy=sockets.target\n</code></pre> <p>Create a <code>/etc/systemd/system/auditize-gunicorn.service</code>:</p> <pre><code>[Unit]\nDescription=Run Auditize using Gunicorn\nRequires=auditize-gunicorn.socket\nAfter=network.target\n\n[Service]\nType=notify\nNotifyAccess=main\nUser=www-data\nGroup=www-data\nWorkingDirectory=/opt/auditize\nEnvironmentFile=/opt/auditize/env\nExecStart=/opt/auditize/bin/gunicorn 'auditize:asgi()' \\\n  --error-logfile /opt/auditize/log/gunicorn.log \\\n  -k uvicorn.workers.UvicornWorker -w 4\nExecReload=/bin/kill -s HUP $MAINPID\nKillMode=mixed\nTimeoutStopSec=5\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>The <code>-w 4</code> option tells Gunicorn to run 4 workers. You can adjust this number according to your needs / host resources.</p> <p>Enable and start the <code>auditize-gunicorn.socket</code> (<code>systemd</code> will start the <code>auditize-gunicorn.service</code> when needed) :</p> <pre><code>sudo systemctl enable --now auditize-gunicorn.socket\n</code></pre>"},{"location":"install/#setup-nginx","title":"Setup Nginx","text":"<p>Install Nginx:</p> <pre><code>sudo apt install nginx\n</code></pre> <p>Add this Nginx configuration file at <code>/etc/nginx/sites-available/auditize</code>:</p> <pre><code>server {\n    listen 80;\n\n    location / {\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_redirect off;\n        proxy_buffering off;\n        proxy_pass http://gunicorn;\n    }\n}\n\nupstream gunicorn {\n    server unix:/run/gunicorn.sock;\n}\n</code></pre> <p>Remove the default Nginx configuration if any:</p> <pre><code>sudo rm /etc/nginx/sites-enabled/default\n</code></pre> <p>Enable the Auditize configuration for Nginx:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/auditize /etc/nginx/sites-enabled/auditize\n</code></pre> <p>Restart Nginx:</p> <pre><code>sudo systemctl restart nginx\n</code></pre> <p>You can now access Auditize at <code>http://YOUR_SERVER_HOSTNAME</code> and log in with the superadmin user you created earlier.</p>"},{"location":"install/#tls","title":"TLS","text":"<p>It is of course highly recommended to use TLS for your Auditize instance. Here is an example of an Nginx configuration with TLS, it has been generated using the Mozilla SSL Configuration Generator and it assumes that you have a valid certificate, private key, and DH parameter files in <code>/opt/auditize/ssl/</code>:</p> <pre><code># generated 2024-10-08, Mozilla Guideline v5.7, nginx 1.17.7, OpenSSL 1.1.1k, intermediate configuration\n# https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=intermediate&amp;openssl=1.1.1k&amp;guideline=5.7\n\n# adapted for Auditize\n\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    location / {\n        return 301 https://$host$request_uri;\n    }\n}\n\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n\n    ssl_certificate /opt/auditize/ssl/cert.pem;\n    ssl_certificate_key /opt/auditize/ssl/key.pem;\n    ssl_session_timeout 1d;\n    ssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\n    ssl_session_tickets off;\n\n    # curl https://ssl-config.mozilla.org/ffdhe2048.txt &gt; /path/to/dhparam\n    ssl_dhparam /opt/auditize/ssl/dhparam;\n\n    # intermediate configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305;\n    ssl_prefer_server_ciphers off;\n\n    # HSTS (ngx_http_headers_module is required) (63072000 seconds)\n    add_header Strict-Transport-Security \"max-age=63072000\" always;\n\n    # OCSP stapling\n    ssl_stapling on;\n    ssl_stapling_verify on;\n\n    # replace with the IP address of your resolver\n    resolver 127.0.0.1;\n\n    location / {\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_redirect off;\n        proxy_buffering off;\n        proxy_pass http://gunicorn;\n    }\n}\n\nupstream gunicorn {\n    server unix:/run/gunicorn.sock;\n}\n</code></pre> <p>Warning</p> <p>Make sure that the files under <code>/opt/auditize/ssl/</code> have proper permissions:</p> <pre><code>sudo chmod o-rwx /opt/auditize/ssl/*\n</code></pre>"},{"location":"log-data-model/","title":"Log data model","text":""},{"location":"log-data-model/#overview","title":"Overview","text":"<p>Here is an example of a full-featured log such as it is accepted by the <code>POST /api/repos/{id}/logs</code> API endpoint:</p> <pre><code>{\n  \"action\": {\n    \"type\": \"job-offer-creation\",\n    \"category\": \"job-offers\"\n  },\n  \"source\": [\n    {\n      \"name\": \"application\",\n      \"value\": \"myATS\"\n    },\n    {\n      \"name\": \"application-version\",\n      \"value\": \"1.0.0\"\n    }\n  ],\n  \"actor\": {\n    \"ref\": \"418b0dc2-5fbc-4e5b-bab2-ba03250455e5\",\n    \"type\": \"user\",\n    \"name\": \"John Pierce\",\n    \"extra\": [\n      {\n        \"name\": \"email\",\n        \"value\": \"john.pierce@example.com\"\n      }\n    ]\n  },\n  \"resource\": {\n    \"ref\": \"d37cf866-a4f8-4146-8c04-f6045b8c7502\",\n    \"type\": \"job-offer\",\n    \"name\": \"Social Media Manager in Arlington\",\n    \"extra\": []\n  },\n  \"details\": [\n    {\n      \"name\": \"job-title\",\n      \"value\": \"Social Media Manager\"\n    }\n  ],\n  \"tags\": [\n    {\n      \"type\": \"important\"\n    }\n  ],\n  \"entity_path\": [\n    {\n      \"ref\": \"860cb19d-4660-4ec6-b596-c9dcefc293e5\",\n      \"name\": \"South\"\n    },\n    {\n      \"ref\": \"a4cdd5d5-f41a-44cd-838c-dd99b29b8d55\",\n      \"name\": \"Texas\"\n    },\n    {\n      \"ref\": \"a6a34c64-12c9-44ac-8a06-f4b99c3205d0\",\n      \"name\": \"Arlington\"\n    }\n  ],\n}\n</code></pre> <p>This structure let's you represent :</p> <ul> <li>the action being performed (<code>action</code>),</li> <li>who is performing the action (<code>actor</code>),</li> <li>what the action is about (<code>resource</code>),</li> <li>the details of the action (<code>details</code>),</li> <li>the entity to which the log is related (<code>entity_path</code>).</li> </ul> <p>The structure is also flexible enough to let you add custom information about the actor, the source, the resource, the details and through the tag system.</p>"},{"location":"log-data-model/#anatomy-of-a-log","title":"Anatomy of a log","text":"<p>Info</p> <p>Values that must respect the <code>[a-z0-9-]+</code> format are used as translation keys that  can be translated through Log i18n Profiles. When no translation is available for a given key, a default translation is inferred from the key itself by the UI.</p>"},{"location":"log-data-model/#action","title":"<code>action</code>","text":"<p>The <code>action</code> object specifies the action being performed. It includes the following fields:</p> <ul> <li><code>type</code>: It should describe the action in a non-ambiguous way, independent of its associated <code>category</code>. For example, if you want to describe the creation of a user, <code>user-creation</code> is preferable to <code>create</code>. This field is required and must respect the <code>[a-z0-9-]+</code> format.</li> <li><code>category</code>: It is used to group related types of actions. For example, you could use <code>user-management</code> for actions whose <code>type</code> is <code>user-creation</code>, <code>user-deletion</code>, etc. This field is required and must respect the <code>[a-z0-9-]+</code> format.</li> </ul> <p>The <code>action</code> object is mandatory.</p>"},{"location":"log-data-model/#source","title":"<code>source</code>","text":"<p>The <code>source</code> object holds information about the source of the action. It is normalized as a list of custom fields and can be used to express any information: the application that triggered the action, the version of the application, an IP address, etc.</p> <p>A custom field must include the following fields:</p> <ul> <li><code>name</code>: The source field name. It must respect the <code>[a-z0-9-]+</code> format.</li> <li><code>value</code>: The source field value. It can be any string.</li> </ul> <p>The <code>source</code> field is optional.</p>"},{"location":"log-data-model/#actor","title":"<code>actor</code>","text":"<p>The <code>actor</code> object identifies the actor behind the action. It includes the following fields:</p> <ul> <li><code>ref</code>: A value that uniquely identifies an actor, regardless of its <code>type</code>. This field is required and can be any string.</li> <li><code>type</code>: The type of the actor. This field is required and must respect the <code>[a-z0-9-]+</code> format.</li> <li><code>name</code>: The name of the actor. This field is required and can be any string.</li> <li><code>extra</code>: An optional list of custom fields that can be used to express any extra custom information about the actor such as an email, a role, etc.</li> </ul> <p>The <code>actor</code> object is optional.</p>"},{"location":"log-data-model/#resource","title":"<code>resource</code>","text":"<p>The <code>resource</code> object identifies the resource being the target of the action. It includes the following fields:</p> <ul> <li><code>ref</code>: A value that uniquely identifies a resource, regardless of its <code>type</code>. This field is required and can be any string.</li> <li><code>type</code>: The type of the resource. This field is required and must respect the <code>[a-z0-9-]+</code> format.</li> <li><code>name</code>: The name of the resource. This field is required and can be any string.</li> <li><code>extra</code>: A list of custom fields that can be used to express any extra custom information about the resource. The <code>name</code> must respect the <code>[a-z0-9-]+</code> format while the <code>value</code> can be any string.</li> </ul> <p>The <code>resource</code> object is optional.</p>"},{"location":"log-data-model/#details","title":"<code>details</code>","text":"<p>The <code>details</code> object holds information about the action. It follows the same structure as the <code>source</code> object but is used to proovide details about the action itself.</p>"},{"location":"log-data-model/#tags","title":"<code>tags</code>","text":"<p><code>tags</code> is a list of elements that can be used to track logs on an arbitrary basis. There are two types of tags:</p> <ul> <li>\"simple\" tags: they are represented by an object with only a <code>type</code> field. The <code>type</code> must respect the <code>[a-z0-9-]+</code> format.</li> <li>\"rich\" tags: they are represented by an object with the three required fields: <ul> <li><code>type</code> (must respect the <code>[a-z0-9-]+</code> format),</li> <li><code>ref</code> (a value that uniquely identifies a resource, whatever its type)</li> <li>and <code>name</code> (can be any string)</li> </ul> </li> </ul>"},{"location":"log-data-model/#entity_path","title":"<code>entity_path</code>","text":"<p>Auditize represents the entities of your application as a hierarchical tree structure. Entities can be anything: a customer company, an organizational unit, a geographical location, etc. Each log must include the full path to the specific entity it is associated with. Example: if your application's organization is divided into regions, states, and cities, and a log is about a job offer in Arlington, Texas, its <code>entity_path</code> could be:</p> <pre><code>[\n  {\n    \"ref\": \"860cb19d-4660-4ec6-b596-c9dcefc293e5\",\n    \"name\": \"South\"\n  },\n  {\n    \"ref\": \"a4cdd5d5-f41a-44cd-838c-dd99b29b8d55\",\n    \"name\": \"Texas\"\n  },\n  {\n    \"ref\": \"a6a34c64-12c9-44ac-8a06-f4b99c3205d0\",\n    \"name\": \"Arlington\"\n  }\n]\n</code></pre> <p>Where:</p> <ul> <li><code>ref</code> is the unique identifier of the entity</li> <li><code>name</code> is the name of the entity</li> </ul> <p><code>entity_path</code> is required and must include at least one element, the <code>ref</code> and <code>name</code> fields are mandatory for each element of the list.</p> <p>By including the full path to each entity, Auditize can construct a tree structure of your entities and display it within the log interface. This allows you to filter logs by entity and navigate through the tree to view logs associated with a specific entity. Although this feature may not be relevant to the previous example, Auditize is also capable of updating its internal tree structure when logs expire or when entities are renamed or moved. The original log path remains unchanged.</p>"},{"location":"log-data-model/#attachments","title":"Attachments","text":"<p>Auditize supports file attachements to logs. To upload one or more files to a log, you must first create the log and then attach the file(s) using the <code>POST /api/repos/{repo_id}/logs/{log_id}/attachments</code> endpoint. In addition to the file content itself, you can specify the following:</p> <ul> <li><code>type</code>: The type of the attachment. This field is required and must follow the <code>[a-z0-9-]+</code> format.</li> <li><code>name</code>: The name of the attachment. f not provided, it defaults to the uploaded file's name.</li> <li><code>mime_type</code>: The MIME type of the attachment. If not provided, it defaults to the MIME type of the uploaded file.</li> </ul>"},{"location":"overview/","title":"Overview","text":"<p>Auditize aims to deliver powerful audit log management capabilities to your software without the burden of developing an in-house solution.</p> <p>It is written in Python, it provides a REST API written in FastAPI and a web interface written in React. It uses PostgresQL as a database and Elasticsearch for log storage and search.</p> <p>Here are the core concepts of Auditize:</p>"},{"location":"overview/#log-repositories","title":"Log Repositories","text":"<p>Log Repositories (also referred to as \"Repositories\" or \"Repos\") serve as containers for logs. Each Log Repository is associated with a dedicated Elasticsearch index, ensuring strong isolation between logs. They allow you to set up specific permissions and settings, such as a retention periods or statuses.</p> <p>You can set up one or more repositories based on your needs. However, to ensure logs consistency you should make sure that a given log repository only contains logs from the same application running in the same environment. You should for instance avoid mixing logs from a pre-production and production environment or logs from different unrelated applications in the same repository.</p> <p>The following settings can be configured for a repository:</p> <ul> <li>Retention period: the time after which logs are automatically deleted</li> <li>Status:<ul> <li>Enabled: logs can be written and read</li> <li>Read-only: logs can only be read</li> <li>Disabled: logs cannot be read nor written</li> </ul> </li> <li>Log i18n Profile: the profile used to translate logs in the web interface</li> </ul>"},{"location":"overview/#users","title":"Users","text":"<p>Users are meant to access Auditize through the web interface. See API keys if you want to access the REST API programmatically. When a user is created, they will receive an email with a link to set their password (make sure that SMTP settings are properly set). Once the password it set, the user will be able to log in to the web interface. Please refer to the Permissions section for permissions details.</p> <p>Note</p> <p>You'll notice that certain permissions or combination of permissions do not seem to make sense for a user. For instance:</p> <ul> <li>a user with the \"write\" permission on the logs of a repository (while it's not possible to send logs through the web interface)</li> <li>a user with only the \"write\" permission on resource management without the corresponding \"read\" permission</li> </ul> <p>This is because the permissions are used for API keys and are also employed to determine what permissions a user can grant to other users.</p>"},{"location":"overview/#api-keys","title":"API keys","text":"<p>API keys are used to access Auditize programmatically through the REST API. Like Users, API keys have a set of Permissions. When a new API key is created, a secret is generated and only shown once. A new secret can be generated for an existing API key (if you lose the secret for instance). In this case, the former secret will no longer be valid.</p>"},{"location":"overview/#permissions","title":"Permissions","text":"<p>Info</p> <p>In this section, we'll refer to \"users\" but the same applies to API keys.</p> <p>Permissions are used to provide access to certain features of Auditize. Permissions can be set on Users and API keys. There are two categories of permissions:</p> <ul> <li>Management permissions</li> <li>Log permissions</li> </ul>"},{"location":"overview/#management-permissions","title":"Management permissions","text":"<p>Management permissions allow you to administrate the various core resources of Auditize:</p> <ul> <li>Repositories (it also covers Log i18n Profiles)</li> <li>Users</li> <li>API keys</li> </ul> <p>On each of these resources, you can set the following permissions:</p> <ul> <li>Read: it allows the user to view the resource</li> <li>Write: it allows the user to alter or delete the resource</li> </ul> <p>Info</p> <p>Setting a read permission to a user without the write permission is like giving an audit access to the resource.</p>"},{"location":"overview/#log-permissions","title":"Log permissions","text":"<p>Log permissions control the access to logs. Permissions can be set either globally or on an per repository basis.</p> <ul> <li>the \"Read\" permission allows the user to view logs</li> <li>the \"Write\" permission allows the user to send logs to the Auditize API</li> </ul> <p>You can also also restrict the read permission to certain log entities instead of the whole repository by setting the \"Entities\" field rather than the \"Read\" field.</p>"},{"location":"overview/#superadmin-role","title":"Superadmin role","text":"<p>When a user is granted the Superadmin role, he has all permissions on all resources and logs.</p> <p>Warning</p> <p>The Superadmin role should be granted with caution and be limited to a small number of users. Setting fine grained permissions to users is recommended.</p>"},{"location":"overview/#granting-permissions","title":"Granting permissions","text":"<p>When a user has the permission to manage Users or API keys (\"write\" permission), the permissions he is allowed to grant are the ones he has himself. For example, if a user has the \"read\" permission on a given repository logs, he is only able to grant the \"read\" permission on this repository to other users.</p> <p>Please note that you need a \"read\" permission on a repository's logs without entity restrictions to grant the \"read\" permission (with or without entity restrictions) to this repository's logs to other users.</p>"},{"location":"overview/#permissions-normalization","title":"Permissions normalization","text":"<p>When saving permissions, they are normalized to ensure consistency and avoid possible side effects in future permissions updates. The normalization process is as follows:</p> <ul> <li>if a user has a global \"read\" log permission (on all repositories), any \"read\" permission explicitly granted on a specific repository (with/without log entity restrictions) is removed</li> <li>if a user has a global \"write\" log permission (on all repositories), any \"write\" permission explicitly granted on a specific repository is removed</li> <li>if a user has the superadmin role, every explicitly granted management/logs permission is removed</li> </ul>"},{"location":"overview/#log-i18n-profiles","title":"Log i18n Profiles","text":"<p>Auditize supports the internationalization of both the web interface and the logs themselves. Log internationalization is managed through Log i18n Profiles. Log i18n Profiles let you upload translation files for the languages you want to support (and are supported by Auditize). The log translation applies to log fields whose value is considered to be a key. Here are the log field type that can be translated:</p> <ul> <li><code>action_type</code></li> <li><code>action_category</code></li> <li><code>actor_type</code></li> <li><code>actor_custom_field</code> (custom field names of the actor)</li> <li><code>source_field</code> (field names within the source)</li> <li><code>detail_field</code> (field names within the details)</li> <li><code>resource_type</code></li> <li><code>resource_custom_field</code> (custom field names of the resource)</li> <li><code>tag_type</code></li> <li><code>attachment_type</code></li> </ul> <p>Example of a translation file:</p> <pre><code>{\n  \"action_type\": {\n    \"job-offer-creation\": \"New job offer\",\n    \"job-offer-close\": \"Job offer closed\",\n    \"job-application\": \"Job application\",\n    \"job-application-status-change\": \"Job application status change\",\n    \"user-creation\": \"User creation\",\n  },\n  \"action_category\": {\n    \"job-offers\": \"Job offers\",\n    \"job-applications\": \"Job applications\",\n    \"users\": \"Users\"\n  },\n  \"detail_field\": {\n    \"granted-role\": \"Granted role\",\n    \"job-title\": \"Job title\",\n    \"reason\": \"Reason\",\n    \"comment\": \"Comment\",\n    \"status\": \"Status\",\n  },\n  \"source_field\": {\n    \"application\": \"Application\",\n    \"application-version\": \"Application version\",\n    \"job-board\": \"Job board\",\n  },\n  \"resource_type\": {\n    \"user\": \"User\",\n    \"job-offer\": \"Job offer\",\n    \"applicant\": \"Candidate\"\n  },\n  \"resource_custom_field\": {},\n  \"actor_type\": {\n    \"applicant\": \"Candidate\",\n    \"user\": \"User\"\n  },\n  \"actor_custom_field\": {\n    \"email\": \"Email\"\n  },\n  \"attachment_type\": {\n    \"resume\": \"Resume\"\n  },\n  \"tag_type\": {\n    \"applicant\": \"Candidate\"\n  }\n}\n</code></pre> <p>Note</p> <p>Auditize currently supports English and French.</p>"},{"location":"sending-logs/","title":"Sending logs","text":"<p>After Auditize is successfully installed, two steps are still necessary to send logs:</p> <ul> <li>Create a log repository.</li> <li>Create an API key with at least write permission for this repository and obtain the associated secret (referred to as the API key throughout the rest of this page).</li> </ul> <p>Here is an example of sending a log to Auditize using <code>curl</code>:</p> <pre><code>curl \\\n  ${AUDITIZE_URL}/api/repos/${AUDITIZE_REPO}/logs \\\n  -H \"Authorization: Bearer ${AUDITIZE_APIKEY}\" \\\n  --json '{\"action\": {\"type\": \"user-login\", \"category\": \"authentication\"}, \"actor\": {\"name\": \"John Doe\", \"ref\": \"john.doe@example.net\", \"type\": \"user\"}, \"entity_path\": [{\"ref\": \"1\", \"name\": \"Customer A\"}]}'\n</code></pre> <p>Another example using Python and requests:</p> <pre><code>#!/usr/bin/env python3\n\nimport os\n\nimport requests\n\nresp = requests.post(\n    f\"{os.environ['AUDITIZE_URL']}/api/repos/{os.environ['AUDITIZE_REPO']}/logs\",\n    headers={\"Authorization\": f\"Bearer {os.environ['AUDITIZE_APIKEY']}\"},\n    json={\n        \"action\": {\"type\": \"user-login\", \"category\": \"authentication\"},\n        \"actor\": {\"name\": \"John Doe\", \"ref\": \"john.doe@example.net\", \"type\": \"user\"},\n        \"entity_path\": [{\"ref\": \"1\", \"name\": \"Customer A\"}],\n    },\n)\nresp.raise_for_status()\nprint(resp.text)\n</code></pre> <p>See also</p> <ul> <li>Log data model</li> <li>POST /api/repos/{repo_id}/logs API documentation</li> <li>POST /api/repos/{repo_id}/logs/{log_id}/attachments API documentation</li> </ul>"},{"location":"source/","title":"Source, license and contribution","text":"<p>Auditize is licensed under the Apache License and source code is available on GitHub.</p> <p>Bug reports, questions and contributions are welcomed !</p> <p>Please use GitHub Issues if you encounter a specific issue with Auditize and GitHub Discussions for general questions or discussions.</p>"},{"location":"web-component/","title":"Web Component","text":""},{"location":"web-component/#how-it-works","title":"How it works","text":"<p>Auditize let's you integrate the log interface right into your application frontend using a Web Component.</p> <p>On your application frontend, you must first include the supporting JavaScript file into your HTML document:</p> <pre><code>&lt;script type=\"module\" src=\"${BASE_URL}/auditize-web-component.mjs\"&gt;&lt;/script&gt;\n</code></pre> <p>Where <code>${BASE_URL}</code> is the URL of your Auditize instance.</p> <p>Then, use the <code>&lt;auditize-logs&gt;</code> tag to include the log interface into your application:</p> <pre><code>&lt;auditize-logs\n  base-url=\"${BASE_URL}\"\n  repo-id=\"${REPO_ID}\"\n  access-token-provider=\"getAccessToken\"\n/&gt;\n</code></pre> <p>The tag supports the following attributes:</p> Attribute Required Description <code>base-url</code> yes The URL of your Auditize instance. <code>repo-id</code> yes The repository ID you want to display the logs from. <code>access-token-provider</code> yes The name of a javascript function that retrieves an Auditize access token (and return it as a <code>Promise&lt;string&gt;</code>) from your own backend. <code>access-token-refresh-interval</code> no The interval in milliseconds at which the access token is refreshed. Default is 300000 (5 minutes). <code>lang</code> no The language to use in the Web Component (UI &amp; log translatable content). Default is <code>en</code>. <p>An access token is obtained by calling the <code>/api/auth/access-token</code> endpoint with an API key. This endpoint generates a short-lived access token (10 minutes by default) which can be used to delegate a sub-scope of permissions to a third-party application (such as the Web Component). The permissions can be any Auditize permission that the API key is allowed to use/grant. In the context of the Web Component, this typically involves granting read permission on the repository from which you want your users to view logs.</p> <p>The request parameters passed to the <code>/api/auth/access-token</code> endpoint will look like this:</p> <pre><code>{\n  \"permissions\": {\n    \"logs\": [\n      {\n        \"repo_id\": \"${REPO_ID}\",\n        \"read\": true\n      }\n    ]\n  }\n}\n</code></pre> <p>Where <code>${REPO_ID}</code> is the same ID you passed to the <code>repo-id</code> attribute of the <code>&lt;auditize-logs&gt;</code> tag.</p> <p>Warning</p> <p>As the access token is visible to your end-user, it should be scoped to the minimum required permissions, like in this example.</p> <p>The call to the <code>/api/auth/access-token</code> Auditize endpoint must be done from your backend to keep the API key secret. The <code>access-token-provider</code> attribute of the <code>&lt;auditize-logs&gt;</code> tag is a JavaScript function that you must implement in your frontend to get the access token from your backend.</p> <p>The <code>AUDITIZE_ACCESS_TOKEN_LIFETIME</code> environment variable defines the lifetime of the access token. Make sure that this value and the value of the <code>access-token-refresh-interval</code> attribute are consistent, meaning that the access token lifetime must be greater than the refresh interval.</p>"},{"location":"web-component/#example","title":"Example","text":"<p>Here is an example of a very basic web application, yet functionnal, written in Python using the FastAPI framework, which integrates the Auditize Web Component.</p> <ol> <li>it serves an HTML page that includes the Auditize Web Component and a JavaScript function named <code>getAccessToken</code></li> <li>the web component calls the <code>getAccessToken</code> function</li> <li>this function does a call to the <code>/access-token</code> endpoint of its own backend</li> <li>this <code>/access-token</code> endpoint calls the Auditize <code>/api/auth/access-token</code> endpoint to get an actual access token and returns it to the frontend</li> <li>the access token is made available to the Web Component and used to authenticate the user to Auditize</li> <li>the <code>getAccessToken</code> function is then called every 5 minutes (the default refresh interval) to get a new access token</li> </ol> <pre><code>import os\n\nimport requests\nfrom fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\n\nAUDITIZE_URL = os.environ[\"AUDITIZE_URL\"]\nAUDITIZE_APIKEY = os.environ[\"AUDITIZE_APIKEY\"]\nAUDITIZE_REPO = os.environ[\"AUDITIZE_REPO\"]\n\nHTML_TEMPLATE = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;script type=\"module\" src=\"{base_url}/auditize-web-component.mjs\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            function getAccessToken() {{\n                return fetch(\"/access-token\")\n                    .then(response =&gt; response.json())\n                    .then(data =&gt; data.access_token);\n            }}\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1 style=\"text-align: center\"&gt;Auditize Web Component Demo&lt;/h1&gt;\n        &lt;auditize-logs\n          base-url=\"{base_url}\"\n          repo-id=\"{repo_id}\"\n          access-token-provider=\"getAccessToken\"\n        /&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n\ndef get_access_token():\n    resp = requests.post(\n        f\"{AUDITIZE_URL}/api/auth/access-token\",\n        json={\n            \"permissions\": {\n                \"logs\": {\"repos\": [{\"repo_id\": AUDITIZE_REPO, \"read\": True}]}\n            }\n        },\n        headers={\n            \"Authorization\": f\"Bearer {AUDITIZE_APIKEY}\",\n        },\n    )\n    resp.raise_for_status()\n    return resp.json()[\"access_token\"]\n\n\napp = FastAPI()\n\n\n@app.get(\"/access-token\")\ndef access_token():\n    return {\"access_token\": get_access_token()}\n\n\n@app.get(\"/\")\ndef index():\n    return HTMLResponse(\n        content=HTML_TEMPLATE.format(\n            base_url=AUDITIZE_URL,\n            repo_id=AUDITIZE_REPO,\n        )\n    )\n</code></pre> <p>To ensure your browser can properly interpret responses from the Auditize API, you must enable CORS requests for your Auditize instance. Please refer to the CORS options in the Configuration section.</p> <p>The Github repository containing this example is available here.</p>"},{"location":"web-component/#limitations","title":"Limitations","text":"<p>The Auditize Web Component is designed to offer a simplified view of a specific log scope, rather than providing all the features of the standard log interface. As a result, it has some limitations.</p> <p>As previously mentioned, the repository selection is controlled by the <code>repo-id</code> attribute of the <code>&lt;auditize-logs&gt;</code> tag. Therefore, unlike the standard log interface, the Web Component can only display logs from a single repository.</p> <p>Additionally, Log filters are not available in the Web Component.</p>"}]}